## 对象内存位置与并发

如果不规定对同一内存地址访问的顺序，那么访问就不是原子的。当两个线程都是“写入者”时，就会产生数据竞争和未定义行为

原子操作作用是当程序对同一内存地址中的数据访问存在竞争，可以使用原子操作来避免未定义行为, 但是原子操作并没有指定访问次序, 只是保证程序不会发生未定义行为

### c++ 原子操作

- **Store 操作**

  `std::atomic::store()` 用于将一个值存储到原子变量中。

- **Load 操作**

  `std::atomic::load()` 用于从原子变量中加载一个值。

- **Read-modify-write 操作**

  原子类型支持的 "读-改-写" 操作包括 `fetch_add()`、`fetch_sub()`、`exchange()` 等。它们在读取原子变量的当前值的同时，进行修改，然后将修改后的结果写回原子变量。

### c++ 内存序

C++ 中原子操作的内存序（memory order）决定了操作的顺序性和同步性。不同的内存序在不同的场景下提供不同程度的性能和一致性保证。

常用的内存序:

- **memory_order_relaxed**：不做顺序保证，优化空间最大。
- **memory_order_release**：确保该操作前的所有操作在它之前完成。
- **memory_order_acquire**：确保该操作后的所有操作在它之后完成。
- **memory_order_acq_rel**：同时具有 `release` 和 `acquire` 的特性，适用于同步操作。
- **memory_order_seq_cst**：提供**最强**的内存顺序约束, 强制顺序一致性，确保原子操作的顺序在全局范围内一致。

### 原子操作的约束

- **禁止拷贝和赋值** 

  拷贝构造和拷贝赋值都会将第一个对象的值进行读取，然后再写入另外一个。对于两个独立的对象，这里就有两个独立的操作了，合并这两个操作必定是不原子的。因此，操作就不被允许.

- **不允许默认构造**

  必须显式地对其进行初始化

- **不支持迭代器和比较操作**

  因为比较操作本身可能涉及读取多个线程共享的值，因此需要额外的同步

- **不支持对 `std::atomic` 类型进行指针或引用的操作**

  `std::atomic` 对象的引用只能在某些原子操作的上下文中使用，不能直接被指针操作

- [使用std::atomic_flag实现自旋锁](../chap5/spinlock_mutex.cpp)

- [`std::atomic<bool>`](../chap5/atomic_bool.cpp)

  - **比较交换（Compare-and-Swap, CAS）**

    将一个变量的当前值与期望值进行比较，如果它们相等，则将该变量的值替换为一个新的值。如果它们不相等，则不做任何修改，并且通常会更新期望值为原子变量的当前值。“比较/交换”函数值是一个bool变量，当返回true时执行存储操作，false则更新期望值。

    - 如果它们相等，说明该变量的值没有被其他线程修改过，就将该变量的值替换为新的值。

    - 如果它们不相等，说明有其他线程修改了该变量，操作失败，通常会更新期望值为变量的当前值。

    c++两种形式的 CAS 操作:

    - `compare_exchange_weak()`

      **伪失败（spurious failure）**：在某些情况下，`compare_exchange_weak()` 可能会出现“伪失败”，即使原子变量的值与期望值相等，操作也可能会返回 `false`。这通常是**因为底层硬件或操作系统调度**造成的，例如线程调度导致的上下文切换。

      伪失败通常会配合一个**循环**使用

    - `compare_exchange_strong()`
    
    ​    行为与 `compare_exchange_weak()` 类似，但它确保在任何情况下，如果原子变量的值与期望值相等，操作会成功执行并返回 `true`。在某些实现上， 它**可能会避免“伪失败”现象**，因此**通常在没有硬件保障的情况下优先选择使用**。
    

​		与`atomic_flag`不同的是: `std::atomic<bool>`可能不是无锁的, 除了`std::atomic_flag`之外，所有原子类型都拥有的特征(`is_lock_free`)

