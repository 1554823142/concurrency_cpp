## 共享数据

`数据竞争`是未定义行为的起因, 保护共享数据结构的最基本的方式，使用C++标准库提供的互斥量

- [互斥量](../chap3/mutex.cpp)</br>
  某些情况下使用全局变量没问题，但大多数情况下， `互斥量通常会与需要保护的数据放在同一类中`，而不是定义成全局变量。这是面向对象设计的准则：将其放在一个类中，就可让他们联系在一起，也可对类的功能进行封装，并进行数据保护
- [线程安全stack](../chap3/t_stack.cpp)
  - `问题原因`</br>
    系统负载高时可能会因为内存分配失败而导致异常。栈中的数据已经被移除，但在获取数据副本的过程中，如果抛出了异常，栈中的数据就会丢失
  - 设计方法：
    - `传递引用参数` </br>
        `voidpop(T&value)` 可以避免了拷贝构造和异常问题（如果返回值的话），因为传递的是引用
    - `返回指针`</br>
        返回指向弹出元素的指针，而不是直接返回元素本身,可以避免拷贝过程中的异常，因为我们只是返回了一个指向原始数据的指针，而没有进行内存分配和拷贝,并且使用智能指针还可以管理内存分配和生命周期，可以避免内存泄露
- **死锁** </br>
  `std::lock`——可以一次性锁住`多个(两个以上)`的互斥量，并且没有副作用(死锁风险)</br>
  当std::lock获取互斥锁时，并尝试从另一个互斥量上再获取锁时，就会有异常抛出，第一个锁也会随着异常而自动释放，所以`std::lock`要么`将两个锁都锁住，要不一个都不锁`

  - [一个死锁的例子](../chap3/dead_lock.cpp)</br>无锁的情况下，仅需要两个线程std::thread对象互相调用join()就能产生死锁
  - `避免死锁`</br>原则：**不要谦让**
    - **方法**
      - `避免嵌套锁`</br>线程获得一个锁时，就别再去获取第二个。*每个线程只持有一个锁，就不会产生死锁*。当需要获取多个锁，使用`std::lock`来做这件事(对获取锁的操作上锁)，避免产生死锁
      - `避免在持有锁时调用外部代码`</br>没有办法确定外部要做什么。外部程序可能做任何事情，包括获取锁
      - `使用固定顺序获取锁`</br>例如：如果两个线程试图用互为反向的顺序，在使用“手递手”遍历列表时，执行到链表中间部分时会发生死锁。当节点A和B在列表中相邻，当前线程可能会同时尝试获取A和B上的锁。另一个线程可能已经获取了节点B上的锁，并试图获取节点A上的锁——经典的`死锁`场景(两个方向都互相想要锁住对方)</br>如果想要解决，就得规定遍历的顺序，如果三个节点的顺序（如顺序来看）为A,B,C,那么一个线程必须先锁住A才能获取B的锁，在锁住B之后才能获取C的锁，即不允许反向遍历链表
      - [使用层次锁结构](../chap3/layer_lock.cpp)</br>
        对应用进行`分层`，并且识别在给定层上所有互斥量。当代码试图对互斥量上锁，而`低层已持有该层锁时，不允许锁定`。可以通过每个互斥量对应的层数，以及每个线程使用的互斥量，在运行时检查锁定操作是否可以进行.

